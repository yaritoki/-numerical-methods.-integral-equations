
import numpy as np
import matplotlib.pyplot as plt
import math
import sympy as sym
from numpy.polynomial.legendre import legval
from sympy import *
from scipy.integrate import quad
from copy import copy
"""
HDyPlot функция строит график
нормы относильной ошибки решение приближенного метода от длинны шага равномерной сетки h
Входные параметры:
func - ссылка на функцию приближенного решения
exact_solution -ссылка на функцию точного решения необходимая для сравнения
Kfunc - ссылка на функцию ядра уравнения (в уранении 1 K(x,s))
f - ссылка на функцию правой части уравнения (в уравнении 1 f(x))
[a,b] - интервал интегрирования
[start_n,end_n] - рассматриваемый диапозон числа разбиений, по умолчанию [5,41]
НЕОБХОДИМО чтобы
функции на которые ссылаются в методе принимали параметры:
func(k,f,a,b,n). где n - число узлов в сетки,
exact_solution(a,b,n)
K(a, b, n)
f(x) где x - число
"""
def HDyPlot(func,exact_solution,Kfunc,f,a,b,start_n=5,end_n=41 ,printgraf=True):
    normErorr=list()
    h=list()
    for n in range(start_n,end_n):
        #приближенное решение
        y,x=func(Kfunc, f, a, b, n)
        #вектор отклонения от точного решения
        error=np.array(exact_solution(a,b,n)-y)
        #Добавление в массив Y норму вектора ошибки
        normErorr.append(math.sqrt(np.dot(error,error))
        /math.sqrt(np.dot(exact_solution(a,b,n),exact_solution(a,b,n))))
        #добавление в масив h длинну шага равномерной сетки
        h.append(x[1]-x[0])
    if printgraf: #построение графика
      plt.semilogy(h, normErorr, label='h')
      plt.xlabel("h")
      plt.ylabel('||dy||')
      plt.legend(["норма относительной ошибки решения"])
      plt.grid(True)
      plt.legend(["ошибка"])
      plt.show()
    else:
       return normErorr , h



"""
функция NDyplot является практически расширением функции hplot
она принимает такие же входные параметры, но с добавлением
rasp_n - ссылка на функцию распределения сектки, что позволяет применять эту функцию
в разных ситуациях
printgraf - булевой параметр, если он равен False то функция вернёт кортеж состоящий
из двух массивов. Первый массив - значения нормы ошибки приближенного решение при разных
количествах узлов сетки , второй - соответсвующее количество разбиений
Иначе в  результате работы выводит график зависимости
нормы относильной ошибки решение приближенного метода от количества узлов сетки
"""
def NDyPlot(func,exact_solution,Kfunc,Ffunc,a,b, start_n, end_n, rasp_n, printgraf=True):
    Y=list()
    N=list()
    for n in range(start_n,end_n,int(end_n/start_n)):
        #вычисляем приближенное решение с помощью функции func
        y,x=func(Kfunc, Ffunc, a, b, n,rasp_n)
        #вычисляем вектор отклонений приближенного решения от точного
        error=np.array(exact_solution(a,b,n,rasp_n)-y)
        #добавляем в массив Y норму относительной ошибки приближенного решения
        Y.append(
            math.sqrt(np.dot(error,error))
            /(math.sqrt(np.dot(exact_solution(a,b,n,rasp_n),exact_solution(a,b,n,rasp_n)))))
        # добавляем в массив N количество разбиений сетки
        N.append(n)
    if printgraf:
      plt.semilogy(N, Y, label='n')
      plt.xlabel("n")
      plt.ylabel('||dy||')
      plt.grid(True)
      plt.legend(["ошибка"])
      plt.show()
    else:
       return Y , N

"""
фунция реализующая метод квадратур для уравнения Вольтерра II рода
с использованием формулы трапеции, в векторной форме  на равномерной сетке.
Входные данные:
K — ядро уравнения(ссыллка на метод, который принимавет параметры (x,s) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки.
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
"""
def Volt_II_Rect_vect_linspace(K,f,a,b,n):
    y = np.zeros(n)
    y[0] = f(a)
    x = np.linspace(a, b, n)
    h = x[1]-x[0]
    for i in range(1, n):
        # по формуле (5) высчитываются y_i
        y[i] = (f(x[i])+h/2*K(x[i], x[0])*y[0]+
                sum( (h *K(x[i], x[1:i])* y[1:i])) )/(1-h/2*K(x[i], x[i]))
    return y,x
"""
фунция реализующая метод квадратур  для уравнения Вольтерра II рода
с использованием формулы трапеции,в векторной форме для разных разбиений сетки.
Входные данные:
K — ядро уравнения(ссыллка на метод, который принимавет параметры (x,s) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки,
rasp_n - ссылка на функцию разбиения сетки, принимает параметры a,b,n.
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
"""
def Volt_II_Rect_vect(K,f,a,b,n,rasp_n):
    y = np.zeros(n)
    y[0] = f(a)
    x = rasp_n(a, b, n)
    h = x[1:] - x[:-1]
    for i in range(1, n):
        y[i] = ((f(x[i])+h[0]/2*K(x[i], x[0])*y[0]+
                sum( (h[1:i] *K(x[i], x[1:i])* y[1:i])) )
                /(1-h[i-1]/2*K(x[i], x[i])))
    return y,x
"""
Фунция реализация метода квадратур для уравнения Вольтерра II рода
с использованием формулы симпсона на равномерной сетки
Входные данные:
K — ядро уравнения(ссыллка на метод, который принимавет параметры (x,s) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки.
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
"""
def Volt_II_Rect_Simpson_linspace(K,f,a,b,n):
    x = np.linspace(a, b, n)
    h = x[1]-x[0]
    rev_h = 1/h
    y = np.zeros(n)
    y[0] = f(x[0])
    #по формуле (4) вычисляем y_i
    y[1] = ((f(x[1]) + h / 2 * K(x[1], x[0]) * y[0]) /
            (1 - h / 2 * K(x[1], x[1])))
    A = [1/3]+[ 2/3 * (1 + divmod(j+1,2)[1]) for j in range(0,n-3)]
    for i in range(2,n):
        y[i] = ((f(x[i]) / h +
                 sum([A[j] * K(x[i], x[j]) * y[j]for j in range(0,i-1)]) +
                (divmod(i+1, 2)[1] * (1 / 2) + (5 / 6)) * K(x[i], x[i - 1]) * y[i - 1]) /
                (rev_h - 1 / (2 + divmod(i+1, 2)[1]) * K(x[i], x[i])))
    return y,x

"""
Фунция реализующая метод квадратур для уравнения Вольтерра II рода
с использованием формулы трапеции, в векторной форме  на равномерной сетке.
Входные данные:
K — ядро уравнения(ссыллка на метод, который принимавет параметры (x,s) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки.
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
"""
def Nonlin_Volt_II_Rect_linspace(K,f,a, b, n):
    y = np.zeros(n)
    x = np.linspace(a, b, n)
    h = x[1] - x[0]
    y[0] = f(x[0])
    for i in range(1, n):
        c = f(x[i]) + h / 2 * K(x[i], x[0]) * y[0] * y[0]
        for j in range(1, i):
            c += h * K(x[i], x[j]) * y[j] * y[j]
            y[i] = (1 - np.sqrt(1 - 4 * (h / 2) * c)) / h

    return y, x

#Используем псевдоним nomr для функции numpy.linalg.norm
norm=np.linalg.norm
"""
Фунция реализующая метод простой  итерации  для уравнения Вольтерра II рода
с использованием формулы трапеции, в векторной форме  на равномерной сетке.
Входные данные:
K — ядро уравнения(ссыллка на метод, который принимавет параметры (x,s) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки.
tol - точность которую мы хотим достигнуть
y0 - вектор начального приближения
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
iter - количество проделанных итераций
"""
def Volt_II_SimpleIter_linspace(K, f, a, b, n, tol=1e-10, y0=False):
  x =np.linspace(a,b,n)
  h = x[1]-x[0]
  F = f(x)
  # если начальное приближение не задано то задаим его y0(x)=f(x)
  if y0==False:
     y0=copy(F)
  y=np.ones(n)*np.inf
  yk = y0
  iter = 0
  yk[0]=F[0]
  y[0] = F[0]
  #пока норма разности предыдущей и текущей итерации не будет меньше заданой точности
  #цикл будет продолжаться, условие (3)
  while(norm(yk-y,ord=np.inf)/norm(yk,ord=np.inf)>tol):
    #сохраняем прошлую итерацию
    y =copy(yk)
    iter=iter+1
    for i in range(1,n):
      j = range(1,i)
      #по уравнению(2) вычитываетм все y_i(x) новой итерации
      yk[i] = F[i]+h/2*K(x[i],x[0])*y[0]+h/2*K(x[i],x[i])*y[i]+\
      h*np.sum(K(x[i],x[j])*y[j])
  return y, x, iter
"""
Фунция реализующая метод простой итерации  для уравнения Вольтерра II рода
 использованием формулы симпсона,в векторной форме  на равномерной сетке.
Входные данные:
K — ядро уравнения(ссыллка на метод, который принимавет параметры (x,s) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки.
tol - точность которую мы хотим достигнуть
y0 - вектор начального приближения
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
iter - количество проделанных итераций
"""
def Volt_II_SimpleIter_With_Simpson_linspace(K, f, a, b, n, tol=1e-10, y0=False):
  x =np.linspace(a,b,n)
  h = x[1]-x[0]
  F = f(x)
  # если начальное приближение не задано то задаим его y0(x)=f(x)
  if y0==False:
     y0=copy(F)
  y=np.ones(n)*np.inf
  yk = y0
  iter = 0
  yk[0]=F[0]
  y[0] = F[0]
  #пока норма разности предыдущей и текущей итерации не будет меньше заданой точности
  #цикл будет продолжаться, условие (3)
  while(norm(yk-y,ord=np.inf)/norm(yk,ord=np.inf)>tol):
    #сохраняем прошлую итерацию
    y =copy(yk)
    iter=iter+1
    yk[0]=F[0]
    yk[1] = ((F[1] + h / 2 * K(x[1], x[0]) * y[0]) /
            (1 - h / 2 * K(x[1], x[1])))
    for i in range(2,n):
      if divmod(i+1,2)[1]==1:
        A=[h / 3] + [2*h * (1+ divmod(k+1, 2)[1]) / 3 for k in range(0, i - 1)] + [h / 3]
      else:
        A = [h / 3] + [2/3 * h * (1 + (divmod(k+1, 2)[1])) for k in range(0, i - 2)] + [5 * h / 6, h / 2]
      yk[i] = ((F[i] +
                 sum([A[j] * K(x[i], x[j]) * y[j] for j in range(0, i)]))/
                (1 - A[i] * K(x[i], x[i])))
  return y, x, iter
"""
фунция реализация метода простой итерации для нелинейного уравнения Вольтера II рода
с использованием формулы трапеции, в векторной форме на равномерной сетке
Входные данные:
under_int — подынтегральную функцию(ссыллка на метод, который принимавет параметры (x,s,y) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки.
tol - заданая точность
y0 - начальное приближение (если оно не задано )
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
"""
def Nonlin_Volt_II_SimpleIter_linspace(under_int, f, a, b, n, tol=1e-10, y0=False):
  x =np.linspace(a,b,n)
  h = x[1]-x[0]
  F = f(x)
  # если начальное приближение не задано то задаим его y0(x)=f(x)
  if y0==False:
     y0=copy(F)
  y=np.ones(n)*np.inf
  yk = y0
  iter = 0
  yk[0]=F[0]
  y[0] = F[0]
   #пока норма разности предыдущей и текущей итерации не будет меньше заданой точности
  #цикл будет продолжаться, условие (3)
  while(norm(yk-y,ord=np.inf)/norm(yk,ord=np.inf)>tol):
    #сохраняем прошлую итерацию
    y =copy(yk)
    iter=iter+1
    for i in range(1,n):
      j = range(1,i)
      #по уравнению(2) вычитываетм все y_i(x) новой итерации
      yk[i] = F[i]+h/2*under_int(x[i],x[0],y[0])+h/2*under_int(x[i],x[i],y[i])
      +h*np.sum(under_int(x[i],x[j],y[j]))
  return y, x, iter
"""
фунция реализация метода квадратур для уравнения Фредгольма II рода
с использованием формулы трапеции, в векторной форме на равномерной сетке
Входные данные:
K — ядро уравнения, (ссыллка на метод, который принимавет параметры (x,s) - числа),
f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
[a,b] — интервал интеграции,
n — количество узлов сетки.
Функция возвращает:
y — вектор приближенного решения в точке узлов сетки.
x - вектор узлов равномерной сетки
"""
def fred_II_trapez_linspace(K, f, l, a, b, n):
    # Генерация равномерной сетки на интервале [a, b]
    x = np.linspace(a, b, n)
    # Вычисление шага сетки
    h = x[1] - x[0]
    # Вычисление весов w для формулы трапеций
    w = np.concatenate(([1/2], np.ones(n-2), [1/2])) * h * l
    # Инициализация матрицы A нулями
    A = np.zeros((n, n))

    # Заполнение матрицы A
    for i in range(n):
        # Вычисление вклада каждой точки сетки в уравнение
        A[:, i] = -w[i] * K(x, x[i])
        # Добавление диагонального элемента к A
        A[i, i] = A[i, i] + 1

    # Вычисление значений правой части уравнения
    F = f(x)
    # Решение линейной системы уравнений A*y = F
    y = np.linalg.solve(A, F)

    return y, x

"""
 метод Degenerate_Fred_II реализует метод вырожденных ядер
входные параметры:
alpha - массив класса sympy.Array является массивом значений a_i i =1,2,...,m из формулы (2)
beta -  - массив класса sympy.Array является массивом значений b_i i =1,2,...,m из формулы (2)
f - символьное выражение класса sympy.core.add.Add является правой части уравнения (1)
a - начало интегрирования, b - конец интегрирования в уравнении (1)
Lambda- параметр λ в уравнении(1)
ВАЖНО чтобы размерность массивов alpha и beta была одинаковой
метод возвращает символьное уравнение интегральной функции в виде класса sympy.core.add.Add
"""
def Degenerate_Fred_II(alpha, beta, f, a, b,Lambda):
  x=sym.symbols("x")
  m = len(alpha)
  #иницилизируем матрицу из уравнения (13)
  A=np.zeros((m,m))
  for j in range(m):
    for i in range(m):
      #вычисление элементов матрицы из уравнения (13) с использованием формулы (10)
      A[i,j] = -1*integrate(Lambda*beta[i]* alpha[j], (x, a, b))
    #вычисление диагональных элементов матрицы из уранения (13)
    A[j,j]= 1 + A[j,j]
  #иницилизируем вектор правой части из уравнения (12)
  r=np.zeros(m)
  for j in range(m):
    #вычисляем элементы вектора правой части из уравнения(12) по формуле (11)
    r[j]= integrate(beta[j]*f,(x, a, b))
  #решаем уравнение (13) относительно вектора c
  c = np.linalg.solve(A, r)
  #находим y(x) по формуле (1)
  y = np.dot(c,alpha)*Lambda+f;
  return y


"""
Метод Degenerate_Fred_II_teylor реализует метод вырожденных ядер
 c автоматическим разлодением ядра в ряд Тейлора и представнеии его в вырожденном виде
 Входные параметры:
 K - символьное выражения класса sympy.core.add.Add является ядром уравнения (1)
 n - порядок разложения в ряд Тейлора
 f - символьное выражение класса sympy.core.add.Add является правой части уравнения (1)
 begin - начало интегрирования, end - конец интегрирования в уравнении (1)
 Lambda- параметр λ в уравнении(1)
 haviInfDif наличие у ядра бесконечного числа производных, по умолчанию подразумевается, что не существует
метод возвращает символьное уравнение интегральной функции в виде класса sympy.core.add.Add
"""
def Degenerate_Fred_II_teylor( K,n, f, begin, end,
                       Lambda,haviInfDif=False):
  x, s = symbols('x s')
  #ядро раскладывается в ряд тейлора до n-го порядка и преобразование элементов разложения в массив
  K_teylor=series(K,x,0,n).args
  #проверка наличия бесконечной производной,
  # если таковая имеется то нужно учитывать что в массиве K_teylor присутствует элемент О(x^n)
  if haviInfDif:
    n=len(K_teylor)-1
  else:
    n=len(K_teylor)
  alpha=list()
  beta=list()
  #добавляем элементы из разложения в массивы alpha и beta
  alpha.append(K_teylor[0].subs({s:x}))
  beta.append(1)
  for i in range(n-1,0,-1):
      #если в элементе разложения присутствует коэфициент, x,s
      if len(K_teylor[i].args)==3:
        alpha.append(K_teylor[i].args[0]*K_teylor[i].args[1].subs({s:x}))
        beta.append(K_teylor[i].args[2].subs({s:x}))
      else:
        #иначе если в элементе разложения присутствует коэфициент, x или  s, x или  коэфициент, s
        if len(K_teylor[i].args)==2:
          alpha.append(K_teylor[i].args[0].subs({s:x}))
          beta.append(K_teylor[i].args[1].subs({s:x}))
        #иначе если в элементе разложения присутствует только коэфициент, x или  s
        else:
           alpha.append(1)
           beta.append(K_teylor[i])
  #преобразуем массивы alpha и beta в класс sympy.Array
  alpha = Array(alpha)
  beta=Array(beta)
  #возвращаем метод Degenerate_Fred_II c созданными alpha и beta
  return Degenerate_Fred_II(alpha,beta,f,begin,end,Lambda)



#фунция реализация метода Галеркина - Петрова для уравнения Фредгольма II рода
#на равномерной сетке
#Входные данные:
#fi,psi - линейно-независимых функций из формулы (2) (ссылка на метод)
#K — ядро уравнения, (ссыллка на метод, который принимавет параметры (x,s) - числа),
#f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
#[a,b] — интервал интеграции,
#Lambda - константа из уравнения,
#n — количество узлов сетки
#reg_param - параметр интегрального уравнения.
#Функция возвращает:
#y — вектор приближенного решения в точке узлов сетки.
#x - вектор узлов равномерной сетки
def GalerkinPetrov_Fred_II(fi,psi,K, f, a, b, Lambda, n, reg_param=1e-6):

    # Инициализация массивов для вектора правой части и матрицы коэффициентов
    B = np.zeros(n)  # Вектор правой части
    A = np.zeros((n, n))  # Матрица коэффициентов

    # Цикл для вычисления элементов вектора правой части и матрицы коэффициентов
    for j in range(1, n+1):  # Цикл по степеням psi(x, j)
        # Определение функции для вычисления подынтегральной функции для вычисления B_j
        integrand_B = lambda s, x: psi(x, j) * f(s) * K(x, s)

        # Вычисление B_j с помощью численного интегрирования
        B[j-1] = Lambda * quad(lambda x: quad(integrand_B, a, b, args=(x))[0], a, b)[0]

        for i in range(1, n+1):  # Цикл по степеням fi(x, i)
            # Вычисление элемента A_ij матрицы коэффициентов
            A[i-1, j-1] = quad(lambda x: fi(x, i) * psi(x, j), a, b)[0] - \
                          Lambda * quad(lambda x: quad(lambda s: K(x, s) * fi(s, i) * psi(x, j), a, b)[0], a, b)[0]

    A += np.eye(n) * reg_param

    # Решение системы линейных уравнений для определения коэффициентов c_i
    c = np.linalg.solve(A, B)

    # Вычисление значения функции y(x) на сетке x_vals
    x = np.linspace(a, b)
    y = f(x)

    # Вычисление приближенного решения на сетке x_vals с использованием коэффициентов c_i
    for i in range(n):
        y += c[i] * fi(x, i+1)

    return x, y



#фунция реализация метода коллокации для уравнения Фредгольма II рода
#на равномерной сетке
#Входные данные:
#K — ядро уравнения, (ссыллка на метод, который принимавет параметры (x,s) - числа),
#f — правая сторона(ссылка на метод, который принимавет параметр (x) - число),
#[a,b] — интервал интеграции,
#Lambda - параметр уравнения,
# n - число базисных функций;
# m - число узлов в сетке
#reg_param - параметр интегрального уравнения.
#Функция возвращает:
#y — вектор приближенного решения в точке узлов сетки.
#x - вектор узлов равномерной сетки

def Fred_II_Colloc(K, f,a, b, Lambda, n, m):
    # Генерация точек коллокации
    x = np.linspace(a, b, n+1)
    # Вычисление значений правой части СЛАУ
    F = f(x)
    # Инициализация матрицы СЛАУ
    M = np.zeros((n+1, n+1))

    for i in range(n+1):
        for j in range(n+1):
            # Вычисление интеграла методом quad
            integr, _ = quad(lambda s: Lambda * K(x[i], s) * legval(s, np.eye(n+1)[j-1]), a, b)
            # Вычисление значения базисной функции в точке x(i)
            M[i, j] = legval(x[i], np.eye(n+1)[j-1]) - integr

    # Вычисление числа обусловленности матрицы СЛАУ
    CondNumb = np.linalg.cond(M, np.inf)
    # Решение СЛАУ
    C = np.linalg.solve(M, F)

    # Генерация значений x для вычисления приближенного решения
    x = np.linspace(a, b, m)
    # Инициализация массива для приближенного решения
    y = np.zeros_like(x)

    for i in range(n+1):
        # Вычисление приближенного решения
        y += C[i] * legval(x, np.eye(n+1)[i-1])

    return x, y , CondNumb